'''
Created on 9 Sep 2012

@author: Callum
'''

import random
import math
import pygame
from VirtualCore import VirtualCore
from Instruction import Instruction
from pgu import gui, timer
from GUI import MainGui
from Parser import Parser

class GameEngine(object):
    
    #Global - I will kill you if you add statics
    padding = 3
    colors = (pygame.Color(255,0,0),pygame.Color(0,255,0),pygame.Color(0,0,255),pygame.Color(0,255,255),pygame.Color(255,255,0),pygame.Color(255,0,255))
    
    def __init__(self, pygameDisplay):
        self.initCoreSize = 3016
        self.programNames = []   
        self.menuHeight = 70
        self.infoHeight = 30
        self.display = pygameDisplay
        self.screenWidth = pygame.display.Info().current_w
        self.screenHeight = pygame.display.Info().current_h
        self.errorMessages = []#Record of any error messages generated by the parser, virtual core or engine.
        self.programNames = []
        self.programPaths = [] 
        self.dispIndex = -1
        
        self.drawArea = pygame.Surface((self.screenWidth,self.screenHeight)).convert_alpha()
        self.drawArea.fill((120,120,120)) 
        
        self.gui = MainGui(self.display,(self.screenWidth,self.screenHeight),self.menuHeight,self.initCoreSize)
        self.gui.engine = self
        
        self.rect = self.gui.get_render_area()
        
        self.startGame(self.initCoreSize, [], [])
        
        #self.doResize()
        
    def startGame(self,coreSize,programNames,programPaths):
        self.programNames = programNames
        self.programPaths = programPaths
        programs = []
        parser = Parser(self)
        for path in self.programPaths:
            program = parser.processFile(path)
            if not program == False:
                programs.append(program)
        if not self.errorMessages == []:
            self.gui.open_error_dialog(self.errorMessages)
            self.errorMessages = []
        self.virtualCore = VirtualCore(coreSize)
        c = 0
        for program in programs:
            pos = int((c*coreSize)/len(programs) + random.randint(0, int(1.5 * len(program))))
            self.virtualCore.load(pos, program)
            c +=1      
        self.doResize()
    
    # Pause the game clock    
    def pause(self):
        print "pause"
        self.clock.pause()

    # Resume the game clock
    def resume(self):
        print "resume"
        self.clock.resume()
        
    def doResize(self):
        self.numberInX = math.ceil(math.sqrt((self.screenWidth * self.virtualCore.size)/(self.screenHeight-self.menuHeight-self.infoHeight))) #ratio of x rounded up
        self.numberInY = math.ceil(self.virtualCore.size/self.numberInX) # and so in Y
        
        #the 'perfect' size for each cell would be
        xSize = self.screenWidth/self.numberInX
        ySize = (self.screenHeight-self.menuHeight-self.infoHeight)/self.numberInY
        
        #choose the smaller one to make squares
        if(xSize < ySize):
            self.squareSize = xSize
        else:
            self.squareSize = ySize
        self.fullRender()
    
    def infoRender(self):
        pygame.draw.rect(self.drawArea,pygame.Color(40,40,40),(0,self.screenHeight-self.menuHeight-self.infoHeight,self.screenWidth,self.infoHeight))
        mx,my = pygame.mouse.get_pos()
        down = pygame.mouse.get_pressed()[0]
        if(down and mx > 0 and mx < self.screenWidth and my > 0 and my < (self.screenHeight-self.menuHeight-self.infoHeight)):
            overX = math.floor(mx/self.squareSize)
            overY = math.floor(my/self.squareSize)
            index = int((overY * self.numberInX) + overX)
            if(index < self.virtualCore.size):
                self.dispIndex = index
        dispText = ""
        if(self.dispIndex != -1):
            instruc = self.virtualCore.memory[self.dispIndex]
            dispText = str(self.dispIndex) + ":   " + instruc.name + " "
            for arg in instruc.arguments:
                dispText += arg[0] + str(arg[1]) + " "
                 
        font = pygame.font.Font(None, 25)
        renderedText = font.render(dispText, True, pygame.Color(255,255,255))
        self.drawArea.blit(renderedText,(0,self.screenHeight-self.menuHeight-self.infoHeight))
        
    def partRender(self):
        self.infoRender()
        for index in self.virtualCore.getChanges():
            y = int(index/self.numberInX)
            x = int(index%self.numberInX)
            pygame.draw.rect(self.drawArea,pygame.Color(0,0,0) ,(x*(self.squareSize), y*(self.squareSize),self.squareSize+self.padding,self.squareSize+self.padding), self.padding/2)
            self.renderRectangle(x, y, index)
        self.virtualCore.clearChanges()
        self.display.blit(self.drawArea,(0,0))
        return (self.rect, )
    
    def fullRender(self): #Do the drawing stuff!
        self.virtualCore.clearChanges()
        self.infoRender()
        pygame.draw.rect(self.drawArea,pygame.Color(0,0,0),(0,0,self.screenWidth,self.screenHeight-self.menuHeight-self.infoHeight))
       
        count = 0
        for y in xrange(int(self.numberInY)):
            for x in xrange(int(self.numberInX)):
                self.renderRectangle(x, y, count)       
                count +=1
                if(count == self.virtualCore.size):
                    break;
        self.display.blit(self.drawArea,(0,0))
        return (self.rect, )
    
    def renderRectangle(self, x, y, index):
        instruction = self.virtualCore.memory[index]
        if instruction.lastMod == -1:
            pygame.draw.rect(self.drawArea,pygame.Color(200,200,200) ,(self.padding + x*(self.squareSize),self.padding + y*(self.squareSize),self.squareSize-self.padding,self.squareSize-self.padding), 0)
        else:
            pygame.draw.rect(self.drawArea,self.colors[instruction.lastMod] ,(self.padding + x*(self.squareSize),self.padding + y*(self.squareSize),self.squareSize-self.padding,self.squareSize-self.padding), 0)
        for playerCounter in self.virtualCore.playerCounters: #This could be done quicker
            if index in playerCounter.counters:
                pygame.draw.rect(self.drawArea,pygame.Color(255,255,0) ,(x*(self.squareSize), y*(self.squareSize),self.squareSize+self.padding,self.squareSize+self.padding), self.padding/2)
                
    def run(self):
        self.gui.update()
        pygame.display.flip()
        self.font = pygame.font.SysFont("", 16)
        self.clock = timer.Clock() #pygame.time.Clock()
        
        # Main program loop
        done = False
        while not done:
            startTime = self.clock.get_time() #Time since last loop
                     
            #Update the game state
            if not self.clock.paused and self.virtualCore != None: 
                ret = self.virtualCore.tick()
                if(ret != None): #player out
                    print "Player " + str(ret.playerID) + " who loaded " + self.programNames[ret.playerID] + " lost. There are " + str(ret.playersLeft) + " players remaining"
                    
            #Poll for events and render the screen AFAP until time for next tick
            while (not done) and ((self.clock.get_time() - startTime) < 0.1):   
                # Process events
                
                for event in pygame.event.get():
                    if (event.type == pygame.QUIT or 
                        event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
                        done = True 
                    if event.type == pygame.VIDEORESIZE:
                        self.display = pygame.display.set_mode(event.dict['size'],pygame.RESIZABLE)
                        self.drawArea = pygame.Surface(event.dict['size']).convert_alpha()
                        self.screenWidth = event.dict['size'][0]
                        self.screenHeight = event.dict['size'][1]
                        self.gui.updateSize(event.dict['size'])#TODO rewrite so menu is fixed height
                        pygame.display.update()
                        print self.screenWidth,self.screenHeight
                        self.gui.event(event)
                        self.doResize()
                    else:
                        # Pass the event off to pgu
                        self.gui.event(event)
                    
                self.rect = self.gui.get_render_area()              
                # Render the game
                updates = []
                self.display.set_clip(self.rect)
                lst = self.partRender()
                if (lst):
                    updates += lst
                    
                self.display.set_clip()
                
                # Give pgu a chance to update the display (menu)
                lst = self.gui.update()
                if (lst):
                    updates += lst
                pygame.display.update(updates)
